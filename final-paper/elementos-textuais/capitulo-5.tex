\chapter{Otimizações}

A eficiência computacional é um dos fatores determinantes para o desempenho de um motor de física em tempo real. Em jogos, animações interativas, simulações físicas e aplicações gráficas, a necessidade de atualizações contínuas e a obrigatoriedade de operar dentro de limites rigorosos de tempo tornam indispensável o uso de técnicas de otimização em todos os estágios do pipeline de simulação.

Como qualquer objeto pode potencialmente colidir com qualquer outro, uma simulação contendo $n$ objetos requer $(n-1)+(n-2)+\dots+1 = n(n-1)/2 = O(n^2)$ testes de pares no pior caso. Devido à complexidade quadrática, testar ingenuamente cada par torna-se impraticável mesmo para valores moderados de $n$.

Reduzir o custo associado ao teste de pares afetará o tempo de execução apenas linearmente. Para realmente acelerar o processo, o número de pares testados deve ser reduzido. Essa redução é realizada separando o tratamento de colisões de múltiplos objetos em duas fases: \textit{Broad Phase} e \textit{Narrow Phase}.

Neste capítulo, descrevemos as estratégias clássicas de otimização aplicadas à detecção e resolução de colisões, com foco na divisão entre \textit{Broad Phase} e \textit{Narrow Phase}, no uso de estruturas espaciais, na adoção de passos temporais fixos e na execução multi-thread de simulações físicas.

\section{Objetos delimitadores}

Em sistemas de simulação física e detecção de colisões, a representação geométrica dos objetos influencia diretamente a eficiência dos cálculos. Formas complexas, com muitos vértices ou superfícies não convexas, tornam tais testes significativamente mais custosos. Uma solução comum é empregar aproximações convexas que possibilitam testes rápidos sem sacrificar excessivamente a precisão da simulação.

\begin{figure}[htb]
	\centering
	\includesvg[width=0.7\linewidth]{fecho-convexo-interseccao}
	\caption{Em (A) os objetos delimitadores não se intersectam, em (B) eles se intersectam porém os objetos não se intersectam, em (C) eles se intersectam e os objetos se intersectam.}
	\label{fig:fecho-convexo-interseccao}
\end{figure}

A principal motivação para o uso de objetos delimitadores é que formas mais simples (como caixas ou esferas) permitem testes de sobreposição muito mais baratos do que a geometria original que envolvem. Além disso, se eles se intersectam não necessariamente os objetos se intersectam, mas caso não se intersectam necessariamente os objetos não se intersectam, como ilustrado na Figura~\ref{fig:fecho-convexo-interseccao}. Esse fato pode ser usado para acelerar os testes de colisão, como veremos posteriormente. 

Segundo \citeonline{moller2018}, nem todos os objetos geométricos servem como objetos delimitadores eficazes. As propriedades desejáveis para objetos delimitadores incluem:
\begin{itemize}
	\item Testes de interseção de baixo custo
	\item Ajuste preciso
	\item Cálculo econômico
	\item Fácil de girar e transformar
	\item Consome pouca memória
\end{itemize}
como ilustrado na Figura~\ref{fig:formas-fecho-convexo}.

\begin{figure}[htb]
	\caption{Comparação entre objetos delimitadores}
	\centering
	\includesvg[width=\linewidth]{bounding_volumes}
	\caption{Da esquerda para direita esfera delimitadora, caixa delimitadora alinhada aos eixos, caixa delimitadora orientada, K-DOP e fecho convexo.}
	\label{fig:formas-fecho-convexo}
\end{figure}

\subsection*{Esfera Delimitadora}

As esferas constituem o volume delimitador mais simples, definidas apenas por um centro $c$ e um raio $r$:
$$
\text{Sphere} = \{ x \in \mathbb{R}^3 \; | \; \|x - c\| \le r \}.
$$
Testes de colisão entre esferas são rápidos, porém inadequados para objetos de proporções irregulares. Elipsoides oferecem melhor ajuste, mas aumentam o custo de teste. Por isso, essas formas são frequentemente utilizadas em fases preliminares da detecção, ou como nós intermediários em hierarquias de volumes delimitadores (BVH, do inglês \textit{Bouding Volume Hierarchy}).

\subsection*{Caixa Delimitadora Alinhada ao Eixo Coordenado}

A caixa delimitadora alinhada aos eixos (AABB, do inglês \textit{Axis Align Bounding Box}) é um dos objetos delimitadores mais comuns. Trata-se de um paralelepípedo (ou retângulo, em 2D) cujas faces são paralelas aos eixos do sistema de coordenadas. Seu teste de interseção é simples como no Algoritmo~\ref{alg:interseccao-aabb}.
\begin{algorithm}[htb]
	\caption{Teste de Intersecção AABB}
	\KwIn{A e B: volumes AABB}
	\KwOut{Verdadeiro se houver colisão}
	
	\If{$A.x_{max} < B.x_{min}$ \textbf{ou} $A.x_{min} > B.x_{max}$}{
		\Return{False}
	}
	\If{$A.y_{max} < B.y_{min}$ \textbf{ou} $A.y_{min} > B.y_{max}$}{
		\Return{False}
	}
	\If{$A.z_{max} < B.z_{min}$ \textbf{ou} $A.z_{min} > B.z_{max}$}{
		\Return{False}
	}
	\Return{True}
	\label{alg:interseccao-aabb}
\end{algorithm}
% Neste trabalho foram usadas AABBs por serem simples de implementar e eficientes, porém perdem precisão quando o objeto sofre rotações, pois a caixa permanece alinhada aos eixos globais.

\subsection*{Caixa Delimitadora Orientada}

Uma Caixa Delimitadora Orientada (OBB, do inglês \textit{Oriented Bouding Box}) é uma caixa retangular que pode estar arbitrariamente rotacionada em relação aos eixos do sistema de coordenadas. A representação mais comum é feita por um ponto central $c$, por três vetores ortogonais $\hat{u}_i$ que compõem sua orientação e por extensões $e_i$, que são assumidas serem positivas.

OBBs geralmente oferecem melhor ajuste, especialmente para objetos alongados ou rotacionados, reduzindo falsos positivos. Porém, o teste de interseção é mais caro que o das AABBs e geralmente é feito usando o SAT.

\subsection*{Fecho Convexo}

O Fecho Convexo (FC) de um conjunto finito de pontos p é definido como a menor região convexa que contém todos os pontos em p, sendo frequentemente utilizado como um objeto delimitador. Determinar o fecho convexo é um problema recorrente em computação geométrica, especialmente quando se deseja organizar pontos em estruturas mais simples ou acelerar operações posteriores, como testes de colisão.

Existem vários algoritmos, entre os quais o \textit{Quickhull} é um algoritmo para o cálculo do fecho convexo de um conjunto finito de pontos em qualquer dimensão, adotando uma estratégia de divisão e conquista semelhante ao \textit{quicksort} \cite{barber1996quickhull}.

O Quickhull parte de um conjunto de pontos $S$ e constrói o polígono (ou poliedro) convexo que os contém.  O processo para 2 dimensões pode ser descrito em linhas gerais como no Algoritmo~\ref{alg:quickhull_2d}.
\begin{algorithm}[htb]
	\caption{Quickhull 2D}
	\LinesNumbered
	\SetAlgoLined
	\KwIn{Polígono Convexo}
	\KwOut{Lista dos vértices do fecho convexo}
	
	Encontre os pontos de menor e maior coordenada em $x$; eles pertencem ao fecho convexo.\\
	Use a linha formada pelos dois pontos para dividir o conjunto em dois subconjuntos de pontos, que serão processados de forma recursiva. \\
	Para cada subconjunto, encontre o ponto mais distante da linha; ele forma um triângulo que exclui pontos interiores.\\
	Repita recursivamente os dois passos anteriores nas duas linhas formadas pelos dois novos lados do triângulo. \\
	O processo termina quando todos os subconjuntos estão vazios.
	\label{alg:quickhull_2d}
\end{algorithm}
Apresenta complexidade média $O(n \log n)$ em 2D, podendo chegar a $O(n^2)$ em casos degenerados. Em 3D, adapta-se a construções poliedrais mais complexas, mantendo o mesmo princípio recursivo.

\section{Filtragem e Refinamento}

Em geral, o número de objetos em colisão é muito pequeno e gastar $O(n^2)$ é demais, deseja-se reduzir o tempo esperado para $O(n)$ ou $O(nlogn)$. Para isso divide-se o processo de detecção de colisão em duas partes: uma filtragem dos pares que não precisam ser testados pois, claramente não estão em colisão, e um refinamento nos pares que podem ou não colidir. Para isso usa-se a ideia de objetos delimitadores e também o conceito de localização espacial. 

Nessa primeira parte, chamada de \textit{Broad Phase}, são feitos testes conservadores com objetos delimitadores para evitar testes com geometira consideravelmente complexas. E também como os objetos só podem colidir com outros que estejam próximos, utiliza-se consultas espaciais para identificar apenas aqueles que compartilham regiões próximas do espaço.

As técnicas de partição do espaço são os métodos usados para dividir um espaço em regiões menores e mais simples. Isso é feito para organizar dados espacialmente e melhorar operações de busca e consulta de proxidade. Processo pelo qual o espaço é subdividido em regiões, normalmente células convexas, cada célula na partição mantém uma lista de referências a objetos que nela estão contidos (completamente ou parcialmente). Como os objetos só podem se interceptar se se sobrepuserem à mesma célula, o número de testes de pares de objetos é drasticamente reduzido.

Há muitas estruturas espaciais na literatura, como as hierarquicas: Quadtrees, Octrees, BSP Trees, K-Trees e Ball-trees. Grades uniforme constituem um esquema muito usado de subdivisão espacial. Uma grade pode dividir o espaço em várias células de tamanho igual. Cada objeto é então associado às células com as quais se sobrepõem, como ilustrado na Figura~\ref{fig:grade-uniforme}.

\begin{figure}[htb]
	\caption{Divisão espacial em grade uniforme}
	\centering
	\includesvg[width=0.5\textwidth]{uniform-grid}
	\label{fig:grade-uniforme}
\end{figure}

Uma forma natural de se representar a grade é alocar uma matriz de dimensão correspondente, neste trabalho será feito em 2D, onde cada elemento é uma lista com todos objetos na célula. Esse método sofre com matrizes esparsas, alto consumo de memória, e um tamanho fixo do mundo. Outra forma de representar e evitar esses problema é:
\begin{itemize}
	\item Crie uma tabela hash onde cada elemento representa uma célula e armazena uma lista de objetos que ela contém.
	\item Para um ponto as coordenadas de células inteiras (i, j) são calculadas dividindo as coordenadas contínuas do ponto (x, y) pelo tamanho da célula e tomando o piso do resultado
	$$i = \lfloor{\frac{x}{C}}\rfloor, \quad j = \lceil{\frac{y}{C}}\rfloor,
	$$
	onde C é o tamanho da célula.
	\item Use como função hash $H(i, j) = (i \oplus p_1 + j \oplus p_2) \mod m$, onde $p_1$ e $p_2$ são números primos e m o tamanho da tabela.
	\item Para cada objeto, calcule sua caixa delimitadora e traverse todas as células ocupadas. Salve o objeto em cada célula ocupada ao longo da extensão de sua caixa delimitadora.
	\item Para cada célula ordene os objetos por id
	$$$$
\end{itemize}
Dessa forma, temos uma grade uniforme que mepeia um mundo de tamanho arbitrário (possivelmente infinito) em um grade uniforme de tamanho constante.

Além disso, deve-se tratar o caso em que o mundo seja dinâmico, com objetos se movendo, sendo adicionados e removidos. Para um mundo estático basta inicializar a grade como visto anteriormente, mas para um mundo dinâmico é necessário sempre que um objeto for adicionado na simulação também adiciona-lo à grade, quando um objeto for removido, também remove-lo da grade e a todo passo de tempo recalcular em quais células os objetos que se moveram estão e atualizar na grade. Neste trabalho, por motivos de simplicidade, a grade será limpa a todo passo de tempo e reinicializada.

A fase de filtragem usa essa estrutura de dados para ao invés de testar todos os pares de objetos, testar apenas os pares de objetos que estão contidos na mesma célula da grade, usando suas caixas delimitadoras correspondente. Para isso é necessário ser feito eliminação de duplicatas, pois se dois objetos A e B caem na mesma célula é preciso testar apenas o par (A, B) e não repetir para o par (B, A). 

% Devido à uniformidade da grade, acessar uma célula correspondente a uma determinada coordenada é simples e rápido: os valores das coordenadas do mundo são simplesmente divididos pelo tamanho da célula para obter as coordenadas da célula. Dadas as coordenadas de uma célula específica, localizar as células vizinhas também é trivial.

Em termos de desempenho, um dos aspectos mais importantes dos métodos baseados em grade é a escolha de um tamanho de célula apropriado. A célula deve ter um tamanho aproximado da maior parte dos objetos da cena. Se todos os objetos cabem numa célula de tamanho C, então necessariamente cada objeto pode intersectar, no pior caso, até 4 células em 2D ou 8 células em 3D.

Segundo \citeonline{ericson2004real}, existem quatro questões relacionadas ao tamanho da célula que podem prejudicar o desempenho:
\begin{enumerate}
	\item Células muito pequenas geram atualizações excessivas.
	\item Células grandes demais fazem com que muitos objetos sejam agrupados, reduzindo a eficácia da Broad Phase.
	\item Objetos muito complexos demandam subdivisão para melhorar a qualidade dos testes.
	\item Cenários mistos exigem grades hierárquicas ou abordagens híbridas.
\end{enumerate}
O ideal é que cada objeto caiba exatamente no tamanho de uma célula.

Com essa etapa de filtragem usando grade uniforme concluída temos uma lista de pares de candidatos a colisão P e também uma melhora significativa no tempo esperado de $O(n^2)$ para $O(n)$, onde no pior caso, se muitos (se não todos) objetos cairem sobre a mesma célula, continuamos com $O(n^2)$.

O segundo passo de refinamento realiza testes geométricos precisos nos pares de candidatos P, essa fase é chamada de \textit{Narrow Phase}. Utiliza-se algoritmos mais sofisticados para determinar se os objetos estão de fato colidindo, como SAT, GJK e EPA, vistos anteriormente. Essa fase nem sempre é obrigatória pois, sua aplicação pode se tratar de objetos retangulares que caibam justamente nas dimensões de sua caixa delimitadora.

\section{Como determinar o intervalo de integração da física}

Em física é preciso estabelecer um valor para o passo de tempo, normalmente chamado de dt (do inglês \textit{Delta Time}). Isso depende muito, se o seu problema tiver muitos objetos e restrito ao tempo, usa-se um dt alto, mas se não estiver restrito ao tempo usa-se o melhor dt possível para obter uma simulação suave. Em muitos casos não é interessante usar todo tempo da máquina para simulação física, mas também para renderização.

No geral existem dois esquemas de integração física. A forma mais simples é usar uma integração de passo fixo usando sempre o mesmo dt e garante que a simulação seja reprodutível. Outra forma é integração com passo variável, ela é a forma mais comum de realizar integração física pois é sempre computada o mais rápido possível olhando o dt depende do tempo decorrido do relógio, o problema disso que dependendo da máquina pode fazer mais passos ou menos passos de simulação, em geral fazer mais passos da simulação trás um resultado mais plausível. 

\section{Simulação física separada}

Em programas interativos tradicionais a lógica, a física e a renderização são executadas em uma única \textit{thread}. Nesse modelo, a renderização só ocorre após a conclusão da etapa de física, e qualquer uma das etapas pode se tornar gargalo.

Para um sistema single-thread, a renderização só pode começar depois que a física tiver sido simulada, ou seja, é impossível renderizar antes que a simulação física seja feita, como ilustrado na Figura~\ref{fig:diagrama-threaded}. Nos casos em que uma alta quantidade de cálculo é necessária para a simulação de física, a renderização seria atrasada e a simulação o gargalo, resultando em baixas taxas de quadros e falhas gráficas. O contrário também pode ocorrer: a renderização demorar resulta em um atraso na leitura da entrada do usuário e no processo de simulação física.

Para solucionar esse problema, a simulação física pode ser movida para um \textit{thread} dedicada. A \textit{thread} principal renderiza continuamente utilizando o estado físico mais recente, enquanto a \textit{thread} secundária calcula atualizações físicas em paralelo, como ilustrado na Figura~\ref{fig:diagrama-threaded}.

\begin{figure}[htb]
	\centering
	\includesvg[width=\textwidth]{diagrama-threaded}
	\caption{À esquerda esquema tradicional single-thread. À direita esquema com simulação rodando numa thread dedicada a passo fixo.}
	\label{fig:diagrama-threaded}
\end{figure}

Essa separação permite:
\begin{itemize}
	\item melhor utilização de múltiplos núcleos;
	\item redução da latência na renderização;
	\item maior taxa de quadros mesmo em cenas fisicamente complexas;
	\item desacoplamento total entre física e renderização.
\end{itemize}
Dessa forma, a arquitetura é essencial em jogos modernos e simulações interativas, especialmente em ambientes Web utilizando \textit{Web Workers}.
