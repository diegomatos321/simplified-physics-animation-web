\chapter{Detecção de Colisões}

A detecção de colisões é um componente fundamental em sistemas de simulação física e em animações baseadas em partículas. Esse processo identifica quando dois ou mais objetos entram em contato, determina pontos de interseção e, quando necessário, fornece informações como vetores de penetração e normais que servirão de entrada para a etapa subsequente de resposta física. Em contextos interativos em tempo real, a precisão geométrica absoluta costuma ser sacrificada em favor da eficiência computacional, desde que o comportamento resultante se mantenha visualmente verossímil.

Este capítulo introduz os principais conceitos utilizados no âmbito deste trabalho, descrevendo as representações geométricas mais comuns para objetos convexos e apresentando dois algoritmos amplamente empregados em detecção de colisões: o Teorema do Eixo Separador (SAT, do inglês \textit{Separating Axis Theorem}) e o algoritmo Gilbert-Johnson-Keerthi (GJK). Ambos operam eficientemente em formas convexas e constituem a base de vários motores físicos modernos.

\section{Polígonos convexos}

Um objeto geométrico é definido como um conjunto não vazio, limitado e fechado de pontos. A propriedade de ser fechado implica que sua fronteira pertence ao próprio conjunto, enquanto a limitação garante que exista uma esfera de raio finito que contenha todos os seus pontos. Um plano, por exemplo, é fechado, mas não limitado.

\begin{figure}[htb]
	\centering
	\includesvg[width=0.6\linewidth]{poligono-convexo-concavo}
	\caption{Comparação entre polígono convexo (à esquerda) e polígono côncavo (à direita).}
	\label{fig:poligonos}
\end{figure}
Uma forma é considerada convexa se, para quaisquer dois pontos contidos nessa forma, todo o segmento que os une também estiver contido nela, como ilustrado na Figura~\ref{fig:poligonos}. Uma consequência prática é que, para qualquer linha que atravesse o objeto, esta o intersecta em no máximo dois pontos. Formas não convexas podem ser tratadas como composições de múltiplas partes convexas, o que permite a aplicação direta de algoritmos especializados.

\section{Teorema do Eixo Separador (SAT)}
\label{sec:sat}

O Teorema do Eixo Separador é um dos métodos mais difundidos para detecção de colisão entre polígonos convexos. Além de identificar a presença ou ausência de interseção, o SAT também pode ser utilizado para calcular o vetor de translação mínima (MTV, do inglês \textit{Minimum Translation Vector}), útil para correções geométricas e resposta física.

O SAT é um algoritmo genérico rápido que pode remover a necessidade de ter código de detecção de colisão para cada par tipo de forma, reduzindo assim o código e a manutenção. Ao traçar raios paralelos sob dois objetos (a partir de uma fonte luminosa, por exemplo) se as sombras formadas estiverem separadas então não há colisão, repita esse processo ao redor das formas, caso não encontre uma sombra que esteja separada uma da outra os objetos estão em colisão. O SAT se baseia no teorema geométrico que afirma:

\begin{teorema}
	Dois polígonos convexos $A$ e $B$ não se intersectam se, e somente se, existir um eixo (reta) sobre o qual as projeções de $A$ e $B$ não se sobrepõem.
	\label{theo:sat}
\end{teorema}

Tal eixo é denominado eixo separador, como ilustrado na Figura~\ref{fig:eixo-separador}. Em termos computacionais, o algoritmo testa um conjunto finito de eixos candidatos. Para polígonos, os candidatos suficientes são as normais das faces (ou arestas, em 2D) de ambos os objetos.
\begin{figure}[htb]
	\centering
	\includesvg[width=0.7\linewidth]{eixo-separador}
	\caption{Face escolhida em amarelo, eixo separador perpendicular a face.}
	\label{fig:eixo-separador}
\end{figure}

% \subsection*{Projeção sobre um eixo}

Dado um eixo unitário $\hat{n}$ e um conjunto de vértices $\{ v \}$ de um polígono, a projeção gera um intervalo escalar $[min, max]$ definido por:
\begin{align*}
	min &= \min_i (\hat{n} \cdot \vec{v}_i) \\
	max &= \max_i (\hat{n} \cdot \vec{v}_i).
\end{align*}
A verificação de sobreposição entre dois intervalos $[min_A, max_A]$ e $[min_B, max_B]$ é dada pela condição:
$$
	\text{Sobreposição} \iff max_A \geq min_B \quad \land \quad max_B \geq min_A,
$$
como ilustrado na Figura~\ref{fig:eixo-separador}. Se essa condição falhar em qualquer eixo candidato, os objetos estão separados e o algoritmo pode encerrar imediatamente.

% \subsection*{Algoritmo de Interseção e MTV}

O SAT pode ser estendido para calcular a penetração mínima. Caso todos os eixos apresentem sobreposição, a menor sobreposição encontrada corresponde à magnitude do vetor necessário para resolver a colisão, como mostrado no Algoritmo~\ref{alg:sat_mtv}
\begin{algorithm}[htb]
	\caption{SAT com cálculo do MTV}
	\KwIn{Polígonos convexos $A$ e $B$}
	\KwOut{$\vec{d}$ e $\delta$, ou falso}
	$\vec{d} \leftarrow \vec{0}$ \\
	$\delta \leftarrow \infty$ \\
	\ForEach{aresta $\hat{n}$ de A e B}{
		$\hat{n} \leftarrow$ normal unitária de $\hat{n}$ \\
		$p_1 \leftarrow$ Projeção de $A$ \\
		$p_2 \leftarrow$ Projeção de $B$ \\
		$\Delta \leftarrow$ sobreposição entre $p_1$ e $p_2$ \\
		\If{$\Delta \leq \epsilon$}{
			\Return{False}
		}
		\If{$\Delta < \delta$}{
			$\delta \leftarrow \Delta$ \\
			$\vec{d} \leftarrow \hat{n}$
		}
	}
	\Return{$\vec{d}$, $\delta$}
	\label{alg:sat_mtv}
\end{algorithm},
onde $\epsilon$ é um valor numérico para tratar erros de operação flutuante e deve-se ser um valor baixo. O método possui complexidade linear no número de arestas e é bastante eficiente para polígonos convexos em 2D. Em 3D, entretanto, o número de eixos candidatos cresce significativamente, reduzindo sua praticidade em relação a alternativas como o GJK.

\section{Algoritmo Gilbert-Johnson-Keerthi (GJK)}

O algoritmo original de \citeonline{gjk} calcula a distância mínima entre dois conjuntos convexos, neste trabalho faremos uma versão simplificada, apresentada por \citeonline{muratori2016implementingGJK}, que realiza um teste Booleano GJK (BGJK) para o caso de dois objetos estarem em intersecção, com otimização usando regiões de Voronoi. Esse algoritmo funciona para ambientes 2D, é particularmente eficiente em 3D e é amplamente adotado em motores físicos por sua robustez e excelente desempenho.

% utilizando apenas uma função de suporte capaz de retornar o ponto mais distante de um conjunto em uma direção arbitrária. 

% \subsection*{Soma de Minkowski}

O algoritmo GJK fundamenta-se na soma de Minkowski entre dois conjuntos convexos A e B, definida como
$$
A + B = \{ \vec{x} + \vec{y} \mid \vec{x} \in A,\ \vec{y} \in B \},
$$
onde \( \vec{x} \) e \( \vec{y} \) representam vetores posição associados a pontos pertencentes aos conjuntos \(A\) e \(B\), respectivamente.

Do ponto de vista geométrico, a soma de Minkowski pode ser interpretada como o conjunto de todos os pontos obtidos ao transladar o objeto \(B\) por cada vetor posição pertencente a \(A\), mantendo sua forma e orientação, ou seja, faz-se uma cópia do objeto B centrado em cada ponto de A, como ilustrado na Figura~\ref{fig:soma-minkowski}.

\begin{figure}[htb]
	\centering
	\includesvg[width=0.6\linewidth]{soma-minkowski}
	\caption{Em vermelho a soma de Minkowski, em verde a diferença de Minkowski}
	\label{fig:soma-minkowski}
\end{figure}
Uma propriedade muito útil da soma de Minkowski é o fato de que a soma de dois objetos convexos é um objeto convexo. Para um objeto A, usamos a notação $-A$ para denotar o reflexo de A sobre a origem O. A diferença de Minkowski $A-B$ pode ser obtida calculando a soma de Minkowski de A e $-B$
$$
	A - B = \{\vec{x} - \vec{y} \mid \vec{x} \in A, \vec{y} \in B \},
$$
que pode ser pensado como um processo de varredura que calcula o vetor distância para cada ponto de $B$ em $A$. Neste trabalho, usaremos esse termo para referir a essa operação quando necessário.

A diferença de Minkowski também é chamada de configuração do espaço de
obstáculos (CSO, do inglês \textit{Configuration Space Obstacles}). Esse espaço possui uma propriedade muito útil de que A e B se intersectam se, e somente se, sua CSO contém a origem. Isso se deve ao fato de que se existe um ponto em comum entre A e B onde a diferença de Minkowski é igual a zero, logo, esse ponto coincide com a origem O.

Assim o objetivo do BGJK reduz para determinar se a CSO contém ou não a origem. A grande coisa do BGJK é que você não precisa calcular todo CSO, apenas uma amostra do CSO modificando iterativamente um Simplex dentro da CSO até que o Simplex contenha a origem ou pare por não ser possível a origem estar contida no Simplex.

Um Simplex é definido como a forma mais simples possível em um espaço de k-dimensão. Dessa forma um ponto é 0-simplex, um segmento de reta é 1-simplex, um triângulo é 2-simplex, um tetraedro é 3-simplex, como na Figura~\ref{fig:simplex}.

\begin{figure}[htb]
	\centering
	\includesvg[width=\linewidth]{simplex}
	\caption{Da esquerda para direita 0-simplex, 1-simplex, 2-simplex e 3-simplex}
	\label{fig:simplex}
\end{figure}

A construção de um Simplex dentro da região CSO usa uma função de suporte que é definida tal que: seja A um conjunto qualquer, o suporte de A na direção $\vec{d}$ retorna o ponto que pertence a superfície de A mais distante da origem na direção $\vec{d}$, esse ponto é chamado de ponto de suporte. Matematicamente fazemos $S_A (\vec{d}) = max\{v \cdot a : a \in A\}$.

Também é possível realizar aritmética com função suporte
\begin{align*}
	S_{A+B} (\vec{d}) &= S_A (\vec{d}) + S_B (\vec{d}) \\
	S_{-A} (\vec{d}) &= -S_A (-\vec{d}),
\end{align*}
dessa forma, seja D a diferença de Minkowski de dois objetos convexos A e B, o suporte de D na direção $\vec{d}$ é a diferença dos suportes de A e B: $S_{A-B} (\vec{d}) = S_A (\vec{d}) - S_B (\vec{-d})$, como ilustrado pela Figura~\ref{fig:support_function}. Veremos no final deste capítulo, mesmo o CSO possuindo um infinito número de pontos o GJK consegue trabalhar em seu espaço calculando pontos sobre demanda.

\begin{figure}[htb]
	\centering
	\includesvg[width=0.6\linewidth]{support-function}
	\caption{A função suporte na forma implícita $A - B$ ao longo da direção $\vec{d}$.}
	\label{fig:support_function}
\end{figure}

% \textbf{DEFINIR REGIÃO VORONOI}

\citeonline{linahan2015geometricgjk} mostra o BGJK~\cite{muratori2016implementingGJK} como no Algoritmo~\ref{alg:bgjk}, inicializando um simplex Q com um ponto de suporte S numa direção aleatória do CSO (é comum ser escolhido a direção do centro de A para B). Então S é usado para gerar uma nova direção $\vec{d}$ oposta a S, isso é feito para maximizar a área do Simplex e as chances de conter a origem. O loop principal consiste em três etapas principais: primeiro calcular um novo ponto de suporte na direção atual e verificar se esse ponto ultrapassou a origem (S $\cdot \ \vec{d}$ < 0), se sim a origem não pode estar contida no Simplex Q, caso contrário adicionamos S ao Simplex e continuamos tentando incluir a origem. 

\begin{algorithm}[htb]
	\caption{Boolean GJK}
	\KwIn{Polígonos convexos A e B}
	\KwOut{True se colidindo, False caso contrário}

	S $\leftarrow S_{CSO} (\text{Direção aleatória})$ \\
	Q $\leftarrow$ \{S\} \\
	$\vec{d} \leftarrow -S$ \\
	
	\While{iterações $<$ MAX\_ITER}{
		S $\leftarrow S_{CSO} (\vec{d})$ \\ 
		\If{S $\cdot \vec{d}$ < 0}{
			\Return False
		}
		$Q \leftarrow Q \cup \{S\}$ \\
		\If{DoSimplex(Q, $\vec{d}$)} {
			\Return True
		}
	}

	\Return False
	\label{alg:bgjk}
\end{algorithm}

Por fim, chamamos a rotina \textit{DoSimplex} que é responsável por: calcular se a origem está contida ou não no Simplex Q usando regiões de Voronoi, remover pontos antigos do simplex e procurar por uma nova direção que maximize as chances do próximo ponto de suporte conter a origem. Para cada dimensão é feito uma conta diferente, neste trabalho iremos trabalhar apenas com objetos em 2D, por isso trataremos apenas dos casos 1-simplex e 2-simplex, \citeonline{linahan2015geometricgjk} realiza a prova a corretude e também mostra para 3-simplex. Para detalhar essa rotina usaremos uma conveção de nomear os pontos do Simplex em ordem alfabética, com o ponto mais recente sendo A.

\textbf{1-Simplex}

No caso de 2 pontos, Q=\{A,B\} é um 1-simplex com 3 regiões de Voronoi: dois semiespaços e uma faixa. Se o CSO contiver a origem quando n = 1, a região de Voronoi da faixa deve conter a origem.

\textbf{2-Simplex}

No caso de 3 pontos, Q = \{A, B, C\} é um 2-simplex com 8 regiões de Voronoi: uma para cada um dos três vértices, uma para cada uma das três arestas e duas para as regiões acima e abaixo do triângulo. Se o CSO contém a origem quando n = 2, então as regiões de Voronoi AC, AB, ABC ou ACB devem conter a origem.

% Executar essa operação exige $2|A||B| $ subtrações. Isso é significativo, porque uma forma é composta de um número infinito de pontos.  A grande coisa sobre GJK é que você realmente não precisa calcular a diferença de Minkowski para todos os vértices. Uma vez que ambas as formas são convexas e definidas por vértices, só precisamos realizar esta operação nos vértices mais externos.

%$ Dessa forma, queremos apenas saber se a diferença de Minkowski contém ou não a origem. Se isso acontecer, então sabemos que as formas estão se cruzando, caso contrário, as formas são disjuntas. Isso é feito construindo iterativamente um polígono dentro da diferença de Minkowski que tenta incluir a origem. Se o polígono que construímos contém a origem, então podemos dizer que a diferença de Minkowski contém a origem, logo há interseção entre os dois objetos. Este polígono que queremos construir deve ser da forma mais elementar possível, ou seja, um \textit{simplex}, que equivale em 2D a um triângulo, e em 3D a um tetraedro.

% \subsection*{Função de Suporte}

% O algoritmo GJK começa com um simplex inicial e o refina iterativamente adicionando pontos encontrados usando a função de suporte em uma direção que aponta para a origem. Esse processo continua até que a origem seja encontrada dentro do simplex, indicando uma colisão, ou até que se determine que a origem não está contida, o que significa que não há colisão.

% A função de suporte deve retornar o ponto mais distante em uma direção dentro da diferença de Minkowski. Isso cria um simplex que contém uma área máxima, aumentando, portanto, a chance de que o algoritmo termine rapidamente. Além disso, podemos usar o fato de que todos os pontos retornados desta forma estão na borda da diferença de Minkowski e, portanto, se não pudermos adicionar um ponto além da origem ao longo de alguma direção, sabemos que a diferença de Minkowski não contém a origem. Isso aumenta as chances de o algoritmo sair rapidamente em casos de não interseção.

% % \subsection*{Construção iterativa do simplex}

% O Algoritmo~\ref{alg:gjk} busca determinar se a origem está contida em $A - B$ construindo iterativamente um simplex dentro da diferença de Minkowski.
% \begin{algorithm}[htb]
% 	\caption{GJK}
% 	\LinesNumbered
% 	\KwIn{Polígonos convexos $A$ e $B$}
% 	\KwOut{Verdadeiro se ocorreu colisão}
	
% 	Escolhe-se uma direção inicial $\vec{d}$; \\
% 	$p \leftarrow \text{support}(A - B,\ \vec{d})$ \\
% 	\If{$p \cdot \vec{d} < 0$}{
% 		\Return{False}
% 	}
% 	Atualiza-se o simplex com $p$ e calcula-se nova direção $\vec{d}$; \\
% 	Itera-se até que o simplex contenha a origem ou seja possível concluir ausência de interseção.
% 	\label{alg:gjk}
% \end{algorithm}
% O GJK é eficiente e converge rapidamente na prática, sendo mais apropriado que o SAT em cenários tridimensionais e em motores físicos de uso geral.
