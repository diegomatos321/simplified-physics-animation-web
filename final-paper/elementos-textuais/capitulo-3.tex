\chapter{Detecção de Colisões}

A detecção de colisões é um componente fundamental em sistemas de simulação física e em animações baseadas em partículas. Esse processo identifica quando dois ou mais objetos entram em contato, determina pontos de interseção e, quando necessário, fornece informações como vetores de penetração e normais que servirão de entrada para a etapa subsequente de resposta física. Em contextos interativos em tempo real, a precisão geométrica absoluta costuma ser sacrificada em favor da eficiência computacional, desde que o comportamento resultante se mantenha visualmente verossímil.

Este capítulo introduz os principais conceitos utilizados no âmbito deste trabalho, descrevendo as representações geométricas mais comuns para objetos convexos e apresentando dois algoritmos amplamente empregados em detecção de colisões: o Teorema do Eixo Separador (SAT, do inglês \textit{Separating Axis Theorem}) e o algoritmo Gilbert-Johnson-Keerthi (GJK). Ambos operam eficientemente em formas convexas e constituem a base de vários motores físicos modernos.

\section{Polígonos convexos}

Um objeto geométrico é definido como um conjunto não vazio, limitado e fechado de pontos. A propriedade de ser fechado implica que sua fronteira pertence ao próprio conjunto, enquanto a limitação garante que exista uma esfera de raio finito que contenha todos os seus pontos. Um plano, por exemplo, é fechado, mas não limitado.

\begin{figure}[htb]
	\centering
	\includesvg[width=0.6\linewidth]{poligono-convexo-concavo}
	\caption{Comparação entre polígono convexo (à esquerda) e polígono côncavo (à direita).}
	\label{fig:poligonos}
\end{figure}
Uma forma é considerada convexa se, para quaisquer dois pontos contidos nessa forma, todo o segmento que os une também estiver contido nela, como ilustrado na Figura~\ref{fig:poligonos}. Uma consequência prática é que, para qualquer linha que atravesse o objeto, esta o intersecta em no máximo dois pontos. Formas não convexas podem ser tratadas como composições de múltiplas partes convexas, o que permite a aplicação direta de algoritmos especializados.

\section{Teorema do Eixo Separador (SAT)}
\label{sec:sat}

O Teorema do Eixo Separador é um dos métodos mais difundidos para detecção de colisão entre polígonos convexos. Além de identificar a presença ou ausência de interseção, o SAT também pode ser utilizado para calcular o vetor de translação mínima (MTV, do inglês \textit{Minimum Translation Vector}), útil para correções geométricas e resposta física.

O SAT é um algoritmo genérico rápido que pode remover a necessidade de ter código de detecção de colisão para cada par tipo de forma, reduzindo assim o código e a manutenção. Ao traçar raios paralelos sob dois objetos (a partir de uma fonte luminosa, por exemplo) se as sombras formadas estiverem separadas então não há colisão, repita esse processo ao redor das formas, caso não encontre uma sombra que esteja separada uma da outra os objetos estão em colisão. O SAT se baseia no teorema geométrico que afirma:

\begin{teorema}
	Dois polígonos convexos $A$ e $B$ não se intersectam se, e somente se, existir um eixo (reta) sobre o qual as projeções de $A$ e $B$ não se sobrepõem.
	\label{theo:sat}
\end{teorema}

Tal eixo é denominado eixo separador, como ilustrado na Figura~\ref{fig:eixo-separador}. Em termos computacionais, o algoritmo testa um conjunto finito de eixos candidatos. Para polígonos, os candidatos suficientes são as normais das faces (ou arestas, em 2D) de ambos os objetos.
\begin{figure}[htb]
	\centering
	\includesvg[width=0.7\linewidth]{eixo-separador}
	\caption{Face escolhida em amarelo, eixo separador perpendicular a face.}
	\label{fig:eixo-separador}
\end{figure}

% \subsection*{Projeção sobre um eixo}

Dado um eixo unitário $\hat{n}$ e um conjunto de vértices $\{ v \}$ de um polígono, a projeção gera um intervalo escalar $[min, max]$ definido por:
\begin{align*}
	min &= \min_i (\hat{n} \cdot \vec{v}_i) \\
	max &= \max_i (\hat{n} \cdot \vec{v}_i).
\end{align*}
A verificação de sobreposição entre dois intervalos $[min_A, max_A]$ e $[min_B, max_B]$ é dada pela condição:
$$
	\text{Sobreposição} \iff max_A \geq min_B \quad \land \quad max_B \geq min_A,
$$
como ilustrado na Figura~\ref{fig:eixo-separador}. Se essa condição falhar em qualquer eixo candidato, os objetos estão separados e o algoritmo pode encerrar imediatamente.

% \subsection*{Algoritmo de Interseção e MTV}

O SAT pode ser estendido para calcular a penetração mínima. Caso todos os eixos apresentem sobreposição, a menor sobreposição encontrada corresponde à magnitude do vetor necessário para resolver a colisão, como mostrado no Algoritmo~\ref{alg:sat_mtv}
\begin{algorithm}[htb]
	\caption{SAT com cálculo do MTV}
	\KwIn{Polígonos convexos $A$ e $B$}
	\KwOut{$\vec{d}$ e $\delta$, ou falso}
	$\vec{d} \leftarrow \vec{0}$ \\
	$\delta \leftarrow \infty$ \\
	\ForEach{aresta $\hat{n}$ de A e B}{
		$\hat{n} \leftarrow$ normal unitária de $\hat{n}$ \\
		$p_1 \leftarrow$ Projeção de $A$ \\
		$p_2 \leftarrow$ Projeção de $B$ \\
		$\Delta \leftarrow$ sobreposição entre $p_1$ e $p_2$ \\
		\If{$\Delta \leq \epsilon$}{
			\Return{False}
		}
		\If{$\Delta < \delta$}{
			$\delta \leftarrow \Delta$ \\
			$\vec{d} \leftarrow \hat{n}$
		}
	}
	\Return{$\vec{d}$, $\delta$}
	\label{alg:sat_mtv}
\end{algorithm},
onde $\epsilon$ é um valor numérico para tratar erros de operação flutuante e deve-se ser um valor baixo. O método possui complexidade linear no número de arestas e é bastante eficiente para polígonos convexos em 2D. Em 3D, entretanto, o número de eixos candidatos cresce significativamente, reduzindo sua praticidade em relação a alternativas como o GJK.

\section{Algoritmo de Gilbert-Johnson-Keerthi (GJK)}

O algoritmo de Gilbert-Johnson-Keerthi (GJK) é um algoritmo clássico para calcular distância euclidiana entre dois objetos poligonais convexos, também é capaz de determinar os respectivos pontos mais próximos entre eles. Este algoritmo possui uma complexidade linear em relação ao número de vértices dos objetos e não está restrito a uma dimensão específica, podendo ser usado em qualquer espaço m-dimensional. Para calcular a distância é usado o subalgoritmo de Johnson, que resolve um sistema de equações lineares para combinação de vértices, faces e arestas. O algoritmo de GJK é amplamente utilizado em motores físicos devido à sua eficiência e robustez, especialmente em ambientes tridimensionais~\cite{gjk}.

Com o passar dos anos, o subalgoritmo de distância de Johnson foi trocado a favor de outros mais sofisticados como, por exemplo, o subalgoritmo de Ericson apresentado na SIGGRAPH 2004~\cite{ericson2004gjk}. Este subalgoritmo se baseia numa abordagem geométrica ao invés de algébrica, com otimização usando regiões de Voronoi. Neste trabalho, detalharemos a versão aprimorada do GJK proposta por \citeonline{gjk_enhanced} que é capaz de tratar qualquer objeto curvo convexo, e o subalgoritmo de Ericson. 

O algoritmo de GJK fundamenta-se na soma de Minkowski entre dois conjuntos convexos A e B, definida como
$$
A + B = \{ \vec{x} + \vec{y} \mid \vec{x} \in A,\ \vec{y} \in B \},
$$
onde \( \vec{x} \) e \( \vec{y} \) representam vetores posição associados a pontos pertencentes aos conjuntos \(A\) e \(B\), respectivamente.

Do ponto de vista geométrico, a soma de Minkowski pode ser interpretada como o conjunto de todos os pontos obtidos ao transladar o objeto \(B\) por cada vetor posição pertencente a \(A\), mantendo sua forma e orientação, ou seja, faz-se uma cópia do objeto B centrado em cada ponto de A, como ilustrado na Figura~\ref{fig:soma-minkowski-sem-interseccao}.

\begin{figure}[htb]
	\centering
	\includesvg[width=0.6\linewidth]{soma-minkowski-sem-interseccao}
	\caption{Soma de Minkowski, entre os conjuntos A e B.}
	\label{fig:soma-minkowski-sem-interseccao}
\end{figure}
Uma propriedade muito útil da soma de Minkowski é o fato de que a soma de dois objetos convexos é um objeto convexo. Para um objeto A, usamos a notação $-A$ para denotar o reflexo de A sobre a origem O. A diferença de Minkowski $A-B$ pode ser obtida calculando a soma de Minkowski de A e $-B$
$$
	A - B = A + (-B) = \{\vec{x} - \vec{y} \mid \vec{x} \in A, \vec{y} \in B \},
$$
que pode ser pensado como um processo de varredura que calcula o vetor distância para cada ponto de $B$ em $A$. Neste trabalho, usaremos esse termo para referir a essa operação quando necessário.

A diferença de Minkowski também é chamada de configuração do espaço de obstáculos (CSO, do inglês \textit{Configuration Space Obstacles}). Nesse espaço a distância entre os objetos A e B é igual à distância entre a origem O e o CSO, como ilustrado na Figura~\ref{fig:soma-minkowski-sem-interseccao}, que chamaremos de \textit{MinimumNormPoint(CSO)}. Logo, A e B se intersectam se, e somente se, sua CSO contém a origem. Isso se deve ao fato de que se existe um ponto $p_A \subset A$ igual a $p_B \subset B$, então $p_A - p_B = \vec{0}$ é testemunha que há pelo menos um ponto que coincide com a origem O~\cite{linahan2015geometricgjk}. Compare a Figura~\ref{fig:soma-minkowski-com-interseccao} à Figura~\ref{fig:soma-minkowski-sem-interseccao}. Assim, o objetivo do GJK reduz para determinar se a CSO contém ou não a origem. 
\begin{figure}[htb]
	\centering
	\includesvg[width=0.6\linewidth]{soma-minkowski-com-interseccao}
	\caption{Soma de Minkowski entre os conjuntos A e B em intersecção.}
	\label{fig:soma-minkowski-com-interseccao}
\end{figure}

A grande coisa do algoritmo é que você não precisa calcular todo CSO, apenas uma amostra do CSO usando um mapeamento suporte. Uma função de suporte é definida tal que: seja A um conjunto qualquer, o suporte de A na direção $\vec{d}$ retorna o ponto que pertence a superfície de A mais distante da origem na direção $\vec{d}$, esse ponto é chamado de ponto de suporte. \citeonline{gjk_enhanced} mostraram que é possível representar qualquer objeto convexo com a função suporte correta, como por exemplo:
\begin{align*}
	\text{Politopo}&: S_A (\vec{d}) = max\{v \cdot a : a \in A\}, \\
	\text{Esfera com raio R}&: S_A (\vec{d}) = R \cdot \vec{d}
\end{align*}

Também é possível realizar aritmética com função suporte
\begin{align*}
	S_{A+B} (\vec{d}) &= S_A (\vec{d}) + S_B (\vec{d}) \\
	S_{-A} (\vec{d}) &= -S_A (-\vec{d}),
\end{align*}
dessa forma, seja D a diferença de Minkowski de dois objetos convexos A e B, o suporte de D na direção $\vec{d}$ é a diferença dos suportes de A e B: $S_{A-B} (\vec{d}) = S_A (\vec{d}) - S_B (\vec{-d})$, como ilustrado pela Figura~\ref{fig:support_function}. 
\begin{figure}[htb]
	\centering
	\includesvg[width=0.6\linewidth]{support-function}
	\caption{A função suporte na forma implícita $A - B$ ao longo da direção $\vec{d}$.}
	\label{fig:support_function}
\end{figure}

A busca pelo ponto mais próximo da origem dentro do CSO é sustentado pelo teorema de Carathéodory [Rockafellar96]. O teorema afirma que se um ponto $x$ está no interior do fecho convexo de um conjunto $P$ então $x$ está no interior de um simplex k-dimensional com vértices em $P$. Na literatura também pode ser encontrado como uma combinação convexa de no máximo d + 1 pontos de $P$.

Um Simplex é definido como um politopo de k+1 vértices em um espaço de k-dimensão. Dessa forma um ponto é 0-simplex, um segmento de reta é 1-simplex, um triângulo é 2-simplex, um tetraedro é 3-simplex, como na Figura~\ref{fig:simplex}.
\begin{figure}[htb]
	\centering
	\includesvg[width=\linewidth]{simplex}
	\caption{Da esquerda para direita 0-simplex, 1-simplex, 2-simplex e 3-simplex}
	\label{fig:simplex}
\end{figure}

O teorema de Carathéodory em 2 dimensões afirma que podemos construir um triângulo usando pontos em P que envolve qualquer ponto no interior do fecho convexo de P. Por exemplo, seja P = {(0,0), (0,1), (1,0), (1,1)}. O fecho convexo deste conjunto é um quadrado. Seja x = (1/4, 1/4) no interior do fecho convexo de P. Podemos então construir um conjunto {(0,0),(0,1),(1,0)} = $P'$, cujo fecho convexo é um triângulo e envolve x, como ilustrado na Figura~\ref{fig:caratheodory}.~\cite{caratheodory_wikipedia}
\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\linewidth]{Caratheodorys_theorem_example.png}
	\caption{Ilustração do teorema de Carathéodory. O ponto x está no interior do fecho convexo de P, e também está no interior do fecho convexo de $P'$.}
	\label{fig:caratheodory}
\end{figure}

Usaremos a mesma notação de \citeonline{linahan2015geometricgjk}, $||P||$ para denotar a norma (distância à origem) de um ponto $P$. O algoritmo constrói iterativamente simplexos dentro do CSO mais próximos da origem até que o simplexo pare de mudar. O ponto $P$ de norma mínima desses simplexos serve como aproximações sucessivas para \textit{MinimumNormPoint(CSO)}.

Para politopos, o GJK termina após um número finito de iterações. Para objetos curvos, um termo épsilon deve ser adicionado para evitar loops infinitos e limitar o erro entre a distância de separação calculada e real. Foi estabelecido em  
%adicionar citação
que a distância ao quadrado entre a aproximação $P$ e o \textit{MinimumNormPoint(CSO)} real é limitada a um valor inferior a $P \cdot V$, onde V é o ponto de suporte do CSO na direção $-P$. Assim, se $||P||^2 - P \cdot V \leq \epsilon^2$, para alguma constante real muito pequena $\epsilon \geq 0$, concluímos que V não é mais extremo na direção $-P$ do que o próprio P e a distância do CSO à origem é ||P||. O algoritmo GJK é apresentado no Algoritmo~\ref{alg:gjk}.
\begin{algorithm}[htb]
	\caption{GJK}
	\KwIn{Polígonos convexos A e B}
	\KwOut{Distância euclidiana entre A e B}

	P $\leftarrow$ Ponto qualquer na CSO \\
	Q $\leftarrow$ \{\} \\
	$V \leftarrow S_{CSO} (\text{-S})$ \\
	
	\While{$||P||^2 - P \cdot V > \epsilon^2$}{
		P $\leftarrow$ MinimumNormPoint($Q \cup \{V\}$) \\
		Q $\leftarrow$ \\
		P $\leftarrow$ $S_{CSO}(-P)$
	}

	\Return $||P||$
	\label{alg:gjk}
\end{algorithm}

O algoritmo GJK começa com um ponto arbitrário P no CSO e um conjunto simplex vazio Q,
então calcula um ponto de suporte V na direção –P. Se V não estiver mais distante na direção –P do que o próprio P
, então P deve ser o ponto mais próximo da origem: o algoritmo termina com ||P|| como a
distância do CSO à origem. Caso contrário, o algoritmo adiciona V ao conjunto simplex atual
Q e atualiza P para ser o ponto mais próximo da origem dentro do novo simplex
(PontoNormaMínima(EnvoltórioConvexo(Q))). O simplex Q é reduzido ao menor
subconjunto convexo de Q que ainda contém P, e o ponto de suporte V na direção –P é atualizado para a
próxima iteração.

% \textbf{DEFINIR REGIÃO VORONOI}

Dependendo do problema a ser resolvido, é possível modificar o GJK para apenas determinar se há ou não intersecção entre dois objetos A e B, conhecido como Boolean GJK (BGJK). Neste trabalho foi feito uma implementação apresentada por \citeonline{muratori2016implementingGJK,linahan2015geometricgjk} que é baseado nos avanços de \citeonline{gjk_enhanced} e Ericson, feito no Algoritmo~\ref{alg:bgjk}.
\begin{algorithm}[htb]
	\caption{Boolean GJK}
	\KwIn{Polígonos convexos A e B}
	\KwOut{True se colidindo, False caso contrário}

	S $\leftarrow S_{CSO} (\text{Direção aleatória})$ \\
	Q $\leftarrow$ \{S\} \\
	$\vec{d} \leftarrow -S$ \\
	
	\While{iterações $<$ MAX\_ITER}{
		S $\leftarrow S_{CSO} (\vec{d})$ \\ 
		\If{S $\cdot \vec{d}$ < 0}{
			\Return False
		}
		$Q \leftarrow Q \cup \{S\}$ \\
		\If{DoSimplex(Q, $\vec{d}$)} {
			\Return True
		}
	}

	\Return False
	\label{alg:bgjk}
\end{algorithm}

Inicializando um simplex Q com um ponto de suporte S numa direção aleatória do CSO (é comum ser escolhido a direção do centro de A para B). Então S é usado para gerar uma nova direção $\vec{d}$ oposta a S, isso é feito para maximizar a área do Simplex e as chances de conter a origem. O loop principal consiste em três etapas principais: primeiro calcular um novo ponto de suporte na direção atual e verificar se esse ponto ultrapassou a origem (S $\cdot \ \vec{d}$ < 0), se sim a origem não pode estar contida no Simplex Q, caso contrário adicionamos S ao Simplex e continuamos tentando incluir a origem. 


Por fim, chamamos a rotina \textit{DoSimplex} que é responsável por: calcular se a origem está contida ou não no Simplex Q usando regiões de Voronoi, remover pontos antigos do simplex e procurar por uma nova direção que maximize as chances do próximo ponto de suporte conter a origem. Para cada dimensão é feito uma conta diferente, neste trabalho iremos trabalhar apenas com objetos em 2D, por isso trataremos apenas dos casos 1-simplex e 2-simplex, \citeonline{linahan2015geometricgjk} realiza a prova a corretude e também mostra para 3-simplex. Para detalhar essa rotina usaremos uma conveção de nomear os pontos do Simplex em ordem alfabética, com o ponto mais recente sendo A.

\textbf{1-Simplex}

No caso de 2 pontos, Q=\{A,B\} é um 1-simplex com 3 regiões de Voronoi: dois semiespaços e uma faixa. Se o CSO contiver a origem quando n = 1, a região de Voronoi da faixa deve conter a origem.

\textbf{2-Simplex}

No caso de 3 pontos, Q = \{A, B, C\} é um 2-simplex com 8 regiões de Voronoi: uma para cada um dos três vértices, uma para cada uma das três arestas e duas para as regiões acima e abaixo do triângulo. Se o CSO contém a origem quando n = 2, então as regiões de Voronoi AC, AB, ABC ou ACB devem conter a origem.

% Executar essa operação exige $2|A||B| $ subtrações. Isso é significativo, porque uma forma é composta de um número infinito de pontos.  A grande coisa sobre GJK é que você realmente não precisa calcular a diferença de Minkowski para todos os vértices. Uma vez que ambas as formas são convexas e definidas por vértices, só precisamos realizar esta operação nos vértices mais externos.

%$ Dessa forma, queremos apenas saber se a diferença de Minkowski contém ou não a origem. Se isso acontecer, então sabemos que as formas estão se cruzando, caso contrário, as formas são disjuntas. Isso é feito construindo iterativamente um polígono dentro da diferença de Minkowski que tenta incluir a origem. Se o polígono que construímos contém a origem, então podemos dizer que a diferença de Minkowski contém a origem, logo há interseção entre os dois objetos. Este polígono que queremos construir deve ser da forma mais elementar possível, ou seja, um \textit{simplex}, que equivale em 2D a um triângulo, e em 3D a um tetraedro.

% \subsection*{Função de Suporte}

% O algoritmo GJK começa com um simplex inicial e o refina iterativamente adicionando pontos encontrados usando a função de suporte em uma direção que aponta para a origem. Esse processo continua até que a origem seja encontrada dentro do simplex, indicando uma colisão, ou até que se determine que a origem não está contida, o que significa que não há colisão.

% A função de suporte deve retornar o ponto mais distante em uma direção dentro da diferença de Minkowski. Isso cria um simplex que contém uma área máxima, aumentando, portanto, a chance de que o algoritmo termine rapidamente. Além disso, podemos usar o fato de que todos os pontos retornados desta forma estão na borda da diferença de Minkowski e, portanto, se não pudermos adicionar um ponto além da origem ao longo de alguma direção, sabemos que a diferença de Minkowski não contém a origem. Isso aumenta as chances de o algoritmo sair rapidamente em casos de não interseção.

% % \subsection*{Construção iterativa do simplex}

% O Algoritmo~\ref{alg:gjk} busca determinar se a origem está contida em $A - B$ construindo iterativamente um simplex dentro da diferença de Minkowski.
% \begin{algorithm}[htb]
% 	\caption{GJK}
% 	\LinesNumbered
% 	\KwIn{Polígonos convexos $A$ e $B$}
% 	\KwOut{Verdadeiro se ocorreu colisão}
	
% 	Escolhe-se uma direção inicial $\vec{d}$; \\
% 	$p \leftarrow \text{support}(A - B,\ \vec{d})$ \\
% 	\If{$p \cdot \vec{d} < 0$}{
% 		\Return{False}
% 	}
% 	Atualiza-se o simplex com $p$ e calcula-se nova direção $\vec{d}$; \\
% 	Itera-se até que o simplex contenha a origem ou seja possível concluir ausência de interseção.
% 	\label{alg:gjk}
% \end{algorithm}
% O GJK é eficiente e converge rapidamente na prática, sendo mais apropriado que o SAT em cenários tridimensionais e em motores físicos de uso geral.
